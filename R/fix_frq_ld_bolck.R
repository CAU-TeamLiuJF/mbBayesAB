#!/public/home/liujf/software/program/R-4.3.1-no-dev/bin/Rscript
#!
### 根据不同品种之间LD一致性进行区间确定 ###

# 加载需要的程序包
cat("Loading required packages... \n")
suppressPackageStartupMessages(library("data.table"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("getopt"))

## 命令行参数
spec <- matrix(
  c("prefixs",   "I", 1, "character", "[Required] LD results file[s] generated by Plink",
    "map",       "m", 1, "character", "[Required] map/bim file of plink/NULL",
    "win",       "W", 1, "character", "[Optional] number of SNP in each region before merge, int/'chr'/'whole' [100]",
    "phyNum",    "P", 1, "character", "[Optional] num/pos [num]",
    "bin_merge", "M", 1, "character", "[Optional] fix/ld/frq",
    "seg",       "E", 1, "double",    "[Optional] Criteria for interval consolidation/0.1",
    "out",       "O", 1, "character", "[Optional] output file name prefix/NULL",
    "dir",       "D", 1, "character", "[Optional] working directory/NULL",
    "help",      "h", 0, "logical",   "This is Help!"),
  byrow = TRUE, ncol = 5)
opt <- getopt(spec = spec)

# setwd("/BIGDATA2/cau_jfliu_2/liwn/mbGS/Real/YCJY/AGE/multi")
# opt <- list()
# opt$prefixs="YY_ref LL_ref"
# opt$bin_merge="fix"
# opt$seg=0.1
# opt$win=100
# opt$map="/BIGDATA2/cau_jfliu_2/liwn/mbGS/Real/YCJY/AGE/pA_pB_rmMiss.bim"
# opt$out="YY_LL_ld_0.1_merge_100.txt"

## 检查参数
if (!is.null(opt$help) || (is.null(opt$prefixs) && (is.null(opt$map) && opt$bin_merge == "fix"))) {
  cat(paste(getopt(spec = spec, usage = TRUE), "\n"))
  quit()
}

## 工作文件夹
if (!is.null(opt$dir)) setwd(opt$dir)

## 隐藏summarise的提示信息
options(dplyr.summarise.inform = FALSE)

## map文件
map <- read.table(opt$map)
names(map)[1:4] <- c("CHR", "SNP", "cM", "POS")

## SNP数目
snp_total <- nrow(map)

## 默认参数
if (is.null(opt$bin_merge)) opt$bin_merge <- "ld"
if (is.null(opt$phyNum)) opt$phyNum <- "num"
if (is.null(opt$win)) opt$win <- 100
# if (is.null(opt$slid)) opt$slid <- 25
if (is.null(opt$seg)) opt$seg <- 0.1
if (is.null(opt$out)) opt$out  <- paste(c(opt$prefixs, "merge_bins.txt"), collapse = "_")

## 判断win参数是整数还是字符
is_integer <- grepl('^(?=.)([+-]?([0-9]*)(\\.([0-9]+))?)$', opt$win, perl = TRUE)

## 如果win=1，即输出一个区间，包含所有的标记
if (!is_integer) {
  if (opt$win == "chr") {
    nsnp_bin <- data.frame(table(as.factor(map$CHR)))
    write.table(nsnp_bin$Freq, opt$out, col.names = FALSE, row.names = FALSE)
    cat("The bin file determined by chromosome has been outputed.\n")
  } else if (opt$win == "whole") {
    nsnp_bin <- data.frame(nsnp = snp_total)
    write.table(nsnp_bin, opt$out, col.names = FALSE, row.names = FALSE)
    cat("file with only one region has been outputed.\n")
  } else {
    cat("win can only be chr/whole.\n")
    quit(status = 1)
  }
  quit(status = 0)
} else {
  opt$win <- as.integer(opt$win)
}

## 以物理位置为标准进行划分
if (opt$phyNum == "pos") {
  cat("Dividing bins based on physical position...\n")

  # 设置分组步长
  step_size <- opt$win * 1000

  nsnp_bin <- map %>%
  group_by(CHR, Group = cut(POS, breaks = seq(min(POS), max(POS) + step_size, step_size), labels = FALSE)) %>%
  summarize(Count = n())

  write.table(nsnp_bin$Count, opt$out, col.names = FALSE, row.names = FALSE)
  cat("File contain number of snps in bins defined by physical position has been output to: ", opt$out, "\n")
  cat("Number of bins: ", length(nsnp_bin$Count), "\n")
  quit(status = 0)
}

## 染色体编号
chrs <- unique(map$CHR)

## 输出固定snp数的区间
if (opt$bin_merge == "fix") {
  nsnp_bin <- NULL
  for (i in seq_along(chrs)){
    nsnp_i <- sum(map$CHR == chrs[i])
    win_num <- floor(nsnp_i / opt$win)
    if (win_num < 1) win_num <- 1
    nsnp_bini <- rep(opt$win, win_num)
    nsnp_bini[win_num] <- nsnp_bini[win_num] + nsnp_i - sum(nsnp_bini)
    nsnp_bin <- c(nsnp_bin, nsnp_bini)
  }

  ## 检查SNP数目是否与map文件中相同
  if (snp_total != sum(nsnp_bin)) {
    cat("Error! The number of snps in bins file is inconsistent with the map file.\n")
    cat("bins=", sum(nsnp_bin), "≠", "map=", snp_total, "\n")
    quit(status = 1)
  }
  
  write.table(nsnp_bin, opt$out, col.names = FALSE, row.names = FALSE)
  cat("Number of fixed bins: ", length(nsnp_bin), "\n")
  cat("File contain fixed number of snps in bins has been output to: ", opt$out, "\n")
  quit()
}

## 文件名
prefixs <- unlist(strsplit(opt$prefixs, " "))
if (opt$bin_merge == "ld") {
  files <- paste0(prefixs, ".ld") 
} else if (opt$bin_merge == "frq") {
  files <- paste0(prefixs, ".frq")
} else {
  cat("bin_merge can only be frq/ld.\n")
  quit()
}

# ## 群体个数
# nP <- length(files)

## 检查文件是否存在
if (!file.exists(files[1])) {
   cat(files[1], "not found!\n")
   quit()
} else if (!file.exists(files[2])) {
   cat(files[2], "not found!\n")
   quit()
}

## 读取plink的ld结果
cat("Reading files from plink...\n")
data1 <- fread(files[1])
data2 <- fread(files[2])
cat("results loaded.\n")

## 文件类型（ld/frq文件）
if (opt$bin_merge == "ld") {
  names(data1)[1] <- names(data2)[1] <- "CHR"
  data12 <- inner_join(data1, data2, by = c("CHR", "BP_A", "BP_B"), suffix = c("_1", "_2"))
  
  ## 标记对之间的距离
  data12$dist <- abs(data12$BP_A - data12$BP_B) / 1000
  # data12 <- data12[!data12$dist > opt$max, ]
  
  ## 剔除完全连锁的标记对
  data12 <- subset(data12, !(R2_1 == 1 & R2_2 == 1))
  
  ## 整体相关
  cors <- cor(data12$R2_1, data12$R2_2)
  
} else if (opt$bin_merge == "frq") {
  ## 计算相关的列统一成"R2"
  names(data1)[5] <- names(data2)[5] <- "R2"
  
  data12 <- inner_join(data1, data2, by = c("CHR", "SNP"), suffix = c("_1", "_2"))
  
  trans <- data12$A1_1 == data12$A2_2 & data12$A2_1 == data12$A1_2
  matchs <-  data12$A1_1 == data12$A1_2 & data12$A2_1 == data12$A2_2
  if (sum(trans, matchs) != nrow(data12)) {
    cat("There are other types of conditions, please check (line91)\n")
    quit(status = 1)
  }

  ## 更改碱基和基因频率
  data12$A1_2[trans] <- data12$A1_1[trans]
  data12$A2_2[trans] <- data12$A2_1[trans]
  data12$R2_2[trans] <- 1 - data12$R2_2[trans]

  ## 品种间基因频率相关
  cors <- cor(data12$R2_1, data12$R2_2)
} else {
  cat("bin_merge can only be ld/frq!\n")
  quit(status = 1)
}

## 删除中间文件
rm(data1, data2)

## 报告整体相关去情况
cat("The overall correlation is:", cors, "\n")

## 合并临近区间并重新计算相关的函数
bins_merge <- function(stat_df, stat_bin, data_df, data_bin, seg = NULL) {
  # stat_df=bin_cor; stat_bin="bin_A"; data_df=data12_stat; data_bin="bin_A"; seg=opt$seg

  ## 如果seg为NULL，则设为窗口相关的1倍标准差
  if (is.null(seg)) seg <- sd(stat_df$cor)

  i <- 1
  stat_df[["bin_temp"]] <- NA
  stat_df[["nsnp_new"]] <- NA
  while (i <= nrow(stat_df)) {
    s <- i
    e <- i
    hit <- FALSE
    while (!hit && i <= nrow(stat_df)) {
      if (i < nrow(stat_df)) {
        diff_cor <- abs(stat_df$cor[i] - stat_df$cor[i + 1]) >= seg
        diff_chr <- stat_df$CHR[i] != stat_df$CHR[i + 1]
      } else {
        diff_cor <- TRUE
        diff_chr <- TRUE
      }

      if (diff_cor || diff_chr) {
        e <- i
        hit <- TRUE
      }
      i <- i + 1
    }
    stat_df$bin_temp[s:e] <- stat_df[[stat_bin]][s]
    stat_df$nsnp_new[s:e] <- sum(stat_df$nsnp[s:e])
  }

  ## 重新计算cor
  names(stat_df)[which(names(stat_df) == stat_bin)] <- data_bin
  bin_new <- stat_df[, c(data_bin, "bin_temp", "nsnp_new")]
  data_df <- left_join(data_df, bin_new, by = data_bin)
  stat_df <- dplyr::group_by(data_df, CHR, bin_temp) %>%
    dplyr::summarise(nsnp = mean(nsnp_new), start = min(BP_A, BP_B), end = max(BP_A, BP_B), cor = cor(R2_1, R2_2))

  ## 标准差为0的设为相关设为临近标记相关
  sd0 <- which(is.na(stat_df$cor))
  stat_df$cor[sd0] <- stat_df$cor[sd0 - 1]

  names(stat_df)[2] <- data_bin

  ## 将区间标记改为连续整数
  stat_df[[data_bin]] <- as.numeric(as.factor(stat_df[[data_bin]]))

  return(stat_df)
}

## 初步划分区间
cat("Preliminary division based on ", opt$win, " SNPs in each bins...\n")
map$bin <- NA
map$nsnp <- NA
bin_start <- 1
for (i in seq_along(chrs)){
  ## 第i染色体的SNP数
  nsnp_i <- sum(map$CHR == chrs[i])
  ## 以opt$win为一组可以划分的区间数
  win_num <- floor(nsnp_i / opt$win)
  ## 若该染色体上的标记数少于win，则win_num为1
  if (win_num < 1) win_num <- 1 
  ## 每个区间的SNP数，最后一个区间可以超出opt$win
  nsnp_bin <- rep(opt$win, win_num)
  nsnp_bin[win_num] <- nsnp_bin[win_num] + nsnp_i - sum(nsnp_bin)
  ## 染色体i每个SNP的区间标签
  group <- rep(bin_start:(win_num + bin_start - 1), times = nsnp_bin)
  map$bin[map$CHR == chrs[i]] <- group[1:nsnp_i]
  ## 每个区间的SNP数
  nsnp_bin_map <- rep(nsnp_bin, times = nsnp_bin)
  map$nsnp[map$CHR == chrs[i]] <- nsnp_bin_map
  ## 区间数记录
  bin_start <- bin_start + win_num
}
cat("Number of bins before merging: ", max(map$bin), "\n")

## 为ld结果文件中标记对匹配bin区间
bins <- map[, c("CHR", "SNP", "POS", "bin", "nsnp")]
names(bins)[c(3, 4)] <- c("BP_A", "bin_A")
if (opt$bin_merge == "ld") {
  data12_bin <- inner_join(data12, bins, by = c("CHR", "BP_A"))
  bins <- bins[, -ncol(bins)]
  names(bins) <- c("CHR", "SNP", "BP_B", "bin_B")
  data12_bin <- inner_join(data12_bin, bins, by = c("CHR", "BP_B"))
  data12_stat <- subset(data12_bin, bin_A == bin_B)
} else {
  data12_stat <- inner_join(data12, bins, by = c("CHR", "SNP"), suffix = c("_1", "_2"))
  data12_stat$BP_B <- data12_stat$BP_A
}

## 统计区间内的LD一致性
bin_cor <- dplyr::group_by(data12_stat, CHR, bin_A) %>%
  dplyr::summarise(nsnp = mean(nsnp), start = min(BP_A, BP_B), end = max(BP_A, BP_B), cor = cor(R2_1, R2_2))

## 标准差为0的设为相关设为临近标记相关
if (any((is.na(bin_cor$cor)))) {
  sd0 <- which(is.na(bin_cor$cor))
  for (i in sd0) {
    if (i > max(bin_cor$bin_A) %/% 2) {
        end <- max(bin_cor$bin_A)
    } else {
        end <- 1
    }

    for (j in i:end) {
      if (!is.na(bin_cor$cor[j])) {
        bin_cor$cor[sd0] <- bin_cor$cor[j]
        break
       }
    }
  }
}

cat("Merging adjacent windows base on threshold: ", opt$seg, "...\n")
## 根据一定阈值合并邻近窗口
bin_cor <- bins_merge(bin_cor, "bin_A", data12_stat, "bin_A", opt$seg)

## 检查是否所以的染色体都在bin_cor中
miss_chr <- unique(map$CHR[!map$CHR %in% bin_cor$CHR])
if (length(miss_chr) > 0) {
  ## 增加缺失染色体的标记
  for (i in miss_chr) {
    add <- data.frame(CHR = i, bin_A = max(bin_cor$bin_A) + 1, nsnp = sum(map$CHR == i),
    start = min(map$POS[map$CHR == i]), end = max(map$POS[map$CHR == i]), cor = NA)
    bin_cor <- rbind(bin_cor, add)
  }
} 

## 检查SNP数目是否与map文件中相同
if (snp_total != sum(bin_cor$nsnp)) {
  cat("Error! The number of snps in bins file is inconsistent with the map file.\n")
  cat("bins=", sum(bin_cor$nsnp), "≠", "map=", snp_total, "\n")
  quit(status = 1)
}

write.table(bin_cor, opt$out, col.names = FALSE, row.names = FALSE)
cat("File contain number of snps in bins has been output to: ", opt$out, "\n")
cat("Number of bins after merging: ", nrow(bin_cor), "\n")
